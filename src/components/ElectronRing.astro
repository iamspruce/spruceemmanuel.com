---
// --- (Your Astro frontmatter remains unchanged) ---
interface Electron {
  angle: number;
  link: string;
  label: string;
}
interface Ring {
  rotation: number;
  color: string;
  speed: number;
  electrons: Electron[];
}
interface Props {
  text: string;
  rings: Ring[];
}
const { text, rings } = Astro.props;
const ORBIT_WIDTH = 280;
const ORBIT_HEIGHT = 140;
const ORBIT_RX = ORBIT_WIDTH / 2;
const ORBIT_RY = ORBIT_HEIGHT / 2;
const ORBIT_DRAW_DURATION = 3;
---

<div class="electron-container">
  <div class="center-text">{text}</div>
  {
    rings.map((ring, i) => (
      <div
        class="orbit"
        id={`orbit-${i}`}
        data-rx={ORBIT_RX}
        data-ry={ORBIT_RY}
        style={`
            --orbit-width: ${ORBIT_WIDTH}px;
            --orbit-height: ${ORBIT_HEIGHT}px;
            --orbit-rotation: ${ring.rotation}deg;
            --orbit-color: ${ring.color};
            --orbit-draw-delay: ${i * 0.3}s;
            --electron-fade-delay: calc(${i * 0.3}s + ${ORBIT_DRAW_DURATION}s);
          `}
      >
        <svg
          width={ORBIT_WIDTH}
          height={ORBIT_HEIGHT}
          viewBox={`0 0 ${ORBIT_WIDTH} ${ORBIT_HEIGHT}`}
        >
          <ellipse
            class="orbit-path"
            cx={ORBIT_RX}
            cy={ORBIT_RY}
            rx={ORBIT_RX - 1}
            ry={ORBIT_RY - 1}
            style={`--orbit-draw-duration: ${ORBIT_DRAW_DURATION}s;`}
          />
        </svg>

        {ring.electrons.map((electron) => (
          <a
            href={electron.link}
            class="electron"
            title={electron.label}
            data-initial-angle={electron.angle}
            data-speed={ring.speed}
          >
            <span class="visually-hidden">{electron.label}</span>
          </a>
        ))}
      </div>
    ))
  }
</div>

<script>
  interface ElectronAnimation {
    el: HTMLElement;
    rx: number;
    ry: number;
    speed: number; // Now in degrees per SECOND
    angle: number;
  }

  document.addEventListener("DOMContentLoaded", () => {
    const electronsToAnimate: ElectronAnimation[] = [];
    let animationId: number | null = null;
    let lastTime = performance.now();
    let scale = 1;

    function calculateScale() {
      const width = window.innerWidth;
      if (width < 480) return 0.5;
      if (width < 768) return 0.7;
      if (width < 1024) return 0.85;
      return 1;
    }

    function handleResize() {
      scale = calculateScale();

      document.querySelectorAll(".orbit").forEach((orbit) => {
        (orbit as HTMLElement).style.setProperty(
          "--orbit-scale",
          scale.toString()
        );
      });

      // Recalculate positions *without* scale, letting CSS handle it
      electronsToAnimate.forEach(updatePosition);
    }

    document.querySelectorAll(".electron").forEach((el) => {
      const e = el as HTMLElement;
      const orbit = e.closest(".orbit") as HTMLElement;
      if (!orbit) return;

      const rx = parseFloat(orbit.dataset.rx ?? "0");
      const ry = parseFloat(orbit.dataset.ry ?? "0");
      let angle = parseFloat(e.dataset.initialAngle ?? "0");

      const speedPerFrame = parseFloat(e.dataset.speed ?? "0");
      const speed = speedPerFrame * 60; // deg/sec

      electronsToAnimate.push({ el: e, rx, ry, speed, angle });
    });

    // Optimized position update with responsive scaling
    function updatePosition(e: ElectronAnimation) {
      const rad = (e.angle * Math.PI) / 180;

      /* === THIS IS THE FIX ===
         We remove '* scale' because the parent .orbit element
         is *already* being scaled by CSS.
      */
      const x = e.rx * Math.cos(rad);
      const y = e.ry * Math.sin(rad);

      e.el.style.setProperty("--electron-x", `calc(-50% + ${x}px)`);
      e.el.style.setProperty("--electron-y", `calc(-50% + ${y}px)`);
    }

    function animate(currentTime: number) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      electronsToAnimate.forEach((e) => {
        e.angle += e.speed * deltaTime;

        if (e.angle >= 360) e.angle -= 360;
        else if (e.angle < 0) e.angle += 360;

        updatePosition(e);
      });

      animationId = requestAnimationFrame(animate);
    }

    // Initialize scale
    scale = calculateScale();

    document.querySelectorAll(".orbit").forEach((orbit) => {
      (orbit as HTMLElement).style.setProperty(
        "--orbit-scale",
        scale.toString()
      );
    });

    // Run updatePosition once on init to set starting positions correctly
    electronsToAnimate.forEach(updatePosition);

    // Start animation
    lastTime = performance.now();
    animationId = requestAnimationFrame(animate);

    let resizeTimeout: number;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(handleResize, 150);
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        if (animationId) cancelAnimationFrame(animationId);
      } else {
        lastTime = performance.now();
        animationId = requestAnimationFrame(animate);
      }
    });
  });
</script>

<style>
  .electron-container {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 300px;
    transform: translateZ(0); /* Promotes to its own layer */
  }

  @media (max-width: 1024px) {
    .electron-container {
      min-height: 250px;
    }
  }
  @media (max-width: 768px) {
    .electron-container {
      min-height: 200px;
    }
  }
  @media (max-width: 480px) {
    .electron-container {
      min-height: 150px;
    }
  }

  .center-text {
    position: relative;
    z-index: 10;
    font-size: var(--step-0);
    font-weight: bold;
    color: var(--gray-12);
    text-align: center;
    text-shadow: var(--shadow-s, 0 2px 4px rgba(0, 0, 0, 0.1));
    pointer-events: none;
    max-width: 90%;
  }

  .orbit {
    position: absolute;
    top: 50%;
    left: 50%;
    border-radius: 50%;
    opacity: 0.7;
    width: var(--orbit-width);
    height: var(--orbit-height);
    transform: translate(-50%, -50%) rotate(var(--orbit-rotation))
      scale(var(--orbit-scale, 1));
    will-change: auto;
    transition: transform 0.3s ease;
  }

  .orbit svg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    overflow: visible;
  }

  .orbit-path {
    fill: none;
    stroke: var(--orbit-color);
    stroke-width: 2;
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    animation: drawOrbit var(--orbit-draw-duration, 3s) ease-out
      var(--orbit-draw-delay) forwards;
    filter: drop-shadow(0 8px 12px rgba(0, 0, 0, 0.4));
  }

  @keyframes drawOrbit {
    to {
      stroke-dashoffset: 0;
    }
  }

  .electron {
    position: absolute;
    top: 50%;
    left: 50%;
    width: clamp(12px, 2vw, 16px);
    height: clamp(12px, 2vw, 16px);
    border-radius: 50%;
    cursor: pointer;
    background-color: var(--orbit-color);
    box-shadow:
      0 0 15px var(--orbit-color),
      0 4px 8px rgba(0, 0, 0, 0.3);
    opacity: 0;
    z-index: 15;

    /* Using individual properties */
    translate: var(--electron-x, -50%) var(--electron-y, -50%);
    scale: 1;

    will-change: translate, scale, box-shadow;

    /* Only transition scale and box-shadow */
    transition:
      scale 0.3s ease,
      box-shadow 0.3s ease;

    animation:
      fadeInElectron 0.5s ease-out var(--electron-fade-delay) forwards,
      pulseElectron 2.5s infinite ease-in-out var(--electron-fade-delay);
    backface-visibility: hidden;
    perspective: 1000px;
  }

  @keyframes fadeInElectron {
    to {
      opacity: 1;
    }
  }

  @keyframes pulseElectron {
    0%,
    100% {
      box-shadow:
        0 0 15px var(--orbit-color),
        0 4px 8px rgba(0, 0, 0, 0.3);
    }
    50% {
      box-shadow:
        0 0 25px var(--orbit-color),
        0 6px 16px rgba(0, 0, 0, 0.4);
    }
  }

  .electron:hover {
    scale: 1.5; /* Only change scale */
    z-index: 100;
    box-shadow:
      0 0 25px var(--orbit-color),
      0 6px 12px rgba(0, 0, 0, 0.4);
    animation-play-state: paused;
  }

  .electron:active {
    scale: 1.2; /* Only change scale */
    animation-play-state: paused;
  }

  @media (hover: none) and (pointer: coarse) {
    .electron {
      width: clamp(14px, 3vw, 20px);
      height: clamp(14px, 3vw, 20px);
    }
    .electron:active {
      scale: 1.3;
    }
  }

  .visually-hidden {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
  }

  @media (prefers-reduced-motion: reduce) {
    .electron {
      animation: fadeInElectron 0.5s ease-out var(--electron-fade-delay)
        forwards;
    }
    .orbit-path {
      animation-duration: 1s;
    }
    .orbit {
      transition: none;
    }
  }

  @media (max-width: 480px) {
    .orbit-path {
      filter: none;
    }
    .electron {
      animation: fadeInElectron 0.5s ease-out var(--electron-fade-delay)
        forwards;
    }
  }
</style>
